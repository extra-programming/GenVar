on openStack   send "choose browse tool" to me in .5 second   answer "Load stack script from external file?" with "Nah" or "Load"   if it is "Load" then      send "loadStackScript" to button "loadStackScriptBtn" in 0.5 second   end if   #how about try loadStackScript right now, rather than manually push the button.   pass openStackend openStack#note: complement "loadStackScript" is in the button "loadStackScriptBtn" on card 1#this squawks if there's a failure result, otherwise happens silently.#this is very similar to saveInfoStack, below. Refactor?#Uh-Oh! Be sure of Which stack script is getting saved! I overwrote a mainstack#script with the little script from infoStack when info stack was frontmost!!on saveStackScript stackname   if stackName is empty then      put the mainstack of this stack into stackName         #is always shortname, without prefix "stack"   else if not exists(stack stackName) then      exit saveStackScript   end if      local extraname    if stackname <> the mainstack of this stack then      #substacks shouldn't be saved to same file name as mainstack!      # gonna add suffix "extraname " for substacks      put "-" & stackname into extraname    else      put empty into extraname    end if      local savePath   #put the filename of this stack into savePath  #not good enough if script is called by substack   put the filename of stack the mainstack of this stack into savePath      local whereToSave   put ("file:" & savePath) into whereToSave   #now gotta remove our filename?, OR just use a ".txt" suffix!   set the itemdelimiter to "."   delete last item of whereToSave    put extraname & ".txt" after whereToSave   #[]loadStackScript for substack has to know about this custom name!      #livecode 7+ has textEncode and textDecode which it recommends using for text i/o   #so that unicode and other encodings are shared properly with outside world.   #alternatively, try   open file "log.txt" for utf-8 text read -- Opens a file as UTF-8   # (Also see the textDecode in the loadStackScript in our loadStackScriptBtn script)   set the itemdel to "."   if item 1 of the version > 6 then       put textEncode( the script of this stack, "UTF-8")  into url whereToSave   else      put the script of stack stackName into url whereToSave   end if   local whatHappened   put the result into whatHappened   if whatHappened is not empty then      answer whatHappened   end if   put "saved the script"end saveStackScript#this is very similar to saveStackScript, above. Refactor?on saveInfoStack     local infoText   if not exists (stack "str_variations_info") then      put "Huh? Can't find stack 'str_variations_info'"      exit saveInfoStack   end if   repeat with c = 1 to the number of cards of stack "str_variations_info"      put "#  ======   " && the short name of card c of stack "str_variations_info" & return after infoText      put field "info" of card c of stack "str_variations_info" after infoText      put return & return after infoText   end repeat      #ask file "Save stack script where?" with "genvar.txt"   #put it into savePath   #   if it is empty then    #      exit to top   #   end if   local savePath   #put the filename of this stack into savePath  #not good enough is script is called by substack   put the filename of stack the mainstack of this stack into savePath   local whereToSave   put ("file:" & savePath) into whereToSave   #now gotta remove our filename, OR just use a txt suffix   set the itemdelimiter to "/"   put "README.md" into the last item of whereToSave      #livecode 7+ has textEncode and textDecode which it recommends using for text i/o   #so that unicode and other encodings are shared properly with outside world.   # (Also see the textDecode in the loadStackScript in our loadStackScriptBtn script)   set the itemdel to "."   if item 1 of the version > 6 then       put textEncode( infoText, "UTF-8")  into url whereToSave   else      put infoText into url whereToSave   end if   local whatHappened   put the result into whatHappened   if whatHappened is not empty then      answer whatHappened   end if   put "saved the info"end saveInfoStack#dictionary says, "Sent to the current card when the stack is about to be saved."#"Handle the saveStackRequest message if you need to do cleanup or other actions before a stack is saved."on saveStackRequest   saveStackScript     #works silently unless erro   saveInfoStack       #works silently unless error   pass saveStackRequestend saveStackRequest#Handy utility for gluing two lists together and separating them only if both have content.function concatLists list1 list2 currItemDel   if currItemDel is empty then      put itemDel into currItemDel   end if   if list1 is empty then       return list2   else if list2 is empty then      return list1   else      return list1 & currItemdel & list2    #will normally be using ","   end ifend concatListson testConcatLists   assertListsEqual "concatLists('ac,gt' , '' )" ,    "ac,gt"   assertListsEqual "concatLists('' , 'ac,gt' )" ,    "ac,gt"   assertListsEqual "concatLists('ac,gt' , 'ttt' )" ,    "ac,gt,ttt"   assertListsEqual "concatLists(',' , '' )" ,    ","   assertListsEqual "concatLists(',' , ',' )" ,    ",,,"end testConcatLists#what about rna? "actg" should be #[]test this more, harderfunction randomBase   return item random(4) of bases( )end randomBase#function isBase base   #itemOffset will be 0 if the base isn't found   set wholematches to true   #beware, comma was being found in comma separated list. Maybe wholematches will fix?   return itemOffset( base, bases( ) ) > 0 end isBaseon testIsBase   assertEqual "isBase('a')", true   assertEqual "isBase('c')", true   assertEqual "isBase('t')", true   assertEqual "isBase('g')", true   assertEqual "isBase(',')", false   assertEqual "isBase('u')", false    #unless we use rna which we probably will someday, might   assertEqual "isBase('!')", falseend testIsBasefunction bases   return the bases of this stack  #"a,c,g,t"end bases#verifies that (each CHAR! of) a text string is comprised of bases only!function isBases dataString   repeat for each char c in dataString      if not isBase(c) then return false   end repeat   return trueend isBaseson testIsBases   assertEqual "isBases('a')", true   assertEqual "isBases('c')", true   assertEqual "isBases('t')", true   assertEqual "isBases('actctctgaggggaaattttttttt')", true   assertEqual "isBases('')", true    #valid since it would be the result of deletion of single base    assertEqual "isBases('g')", true   assertEqual "isBases('a,c')", false   assertEqual "isBases('actctctgaggggaaattqttttttt')", false   assertEqual "isBases('u')", false    #unless we use rna which we probably will someday, might   assertEqual "isBases('!')", falseend testIsBasesfunction otherBases base   --given one base (a,c,t, or g), this functions returns   --the other 3 separated by commas.   --Example: otherbases("a") ==> "c,t,g"   --(This is handy when you are doing mutations af some base B, because then you   --can get item 1 or 2 or 3 of otherbases(B)   --   put word 1 of base into base   #getting rid of blanks on both sides   if base is empty then      logErr "in otherBases( ' ' ): Wha? How can I find otherBases of empty base?"      return ""   # should this return empty   end if    local others   repeat for each item c in bases( )      if c is not base then put c & "," after others   end repeat   delete the last char of others   return others   /*   #answer "called otherbases"   local mybases, myOthers, whereBaseIs   put "actg" into mybases   put "c,g,t   a,g,t   a,c,g    a,c,t" into myOthers   put offset(base,mybases) into whereBaseIs   --offset says where something is   if whereBaseIs < 1 or whereBaseIs > 4 then      answer "Bad base '" & base & "'"   else      local finalAnswer      put word whereBaseIs of myOthers into finalAnswer --note "word"      return finalAnswer   end if   */end otherBases#usage: (Hey! In your statement, use single quotes when you mean double quotes.#We'll fix 'em here. You CAN'T use single quotes in your statement. Sorry. Get over it.#      assertEqual "makeAllVariations('a',0)", "a"         ## note: assertEqual will turn the 1st arg into stmt with double quotes, and see if it equals 2nd arg.# assertEqual will provide good errMsg! # other ugly way of doing this....# assertLGM (makeAllVariations("a",0) is "a"), "makeAllVariations('a',0) didn't return 'a' as expected", true  on assertEqual functio, expectedReturn, doDebugIfUnhappy   assertFancyEqual functio, expectedReturn, "#1 is #2", doDebugIfUnhappy   /*if doDebugIfUnhappy is empty then      put true into doDebugIfUnhappy   end if      replace "'" with quote in functio   local actualReturn   do "put (" & functio & ") into actualReturn"      if actualReturn is expectedReturn then      #happy   else      local errMsg      put functio && "returned '" & actualReturn & "'; we expected '" & expectedReturn & "'." into errMsg      logTestErr( errMsg )      if doDebugIfUnhappy then         breakpoint      end if   end if*/end assertEqual#this wil call the listsHaveSameElements( ) to compare the actual result of "functio" to expectedReturnon assertListsEqual functio, expectedReturn, doDebugIfUnhappy   assertFancyEqual functio, expectedReturn, "listsHaveSameElements(#1, #2)", doDebugIfUnhappyend assertListsEqual#allows fancy equality to be determined by calling the specified function#usage:#      assertFancyEqual "makeAllVariations('a',1)", "a,c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,", "listsHaveSameElements(#1, #2)"#What we're saying here is, use the function specified in the third arg to compare the first statement to the 2nd arg (expected answer)on assertFancyEqual functio, expectedReturn, equalityTest, doDebugIfUnhappy   if doDebugIfUnhappy is empty then      put true into doDebugIfUnhappy   end if      replace "'" with quote in functio   local actualReturn   do "put (" & functio & ") into actualReturn"      replace "'" with quote in equalityTest   replace "#1" with quote & actualReturn & quote in equalityTest   replace "#2" with quote & expectedReturn & quote in equalityTest      local worked   do "put (" & equalityTest & ") into worked"      if worked then      #happy   else      local errMsg      put "assert failed:" && functio && "returned '" & actualReturn & "'; we expected '" & expectedReturn & "'." into errMsg      logTestErr( errMsg )      if doDebugIfUnhappy then         answer errMsg & return & "Want to see debugger at breakpoint or Continue?" with "Debug" or "Continue"         if it is "Debug" then            breakpoint         end if      end if   end ifend assertFancyEqual/* not sets: there can be repeated elements (which we'll have to count) *//* If these sets are not too big, we could sort them! */function listsHaveSameElements p q   if p contains return or q contains return then      answer "Whoa! Our lists aren't supposed to have returns in them"      breakpoint      exit to top   end if   if p is empty and q is empty then       return true   end if   local psize,qsize   put the number of items of p into psize   put the number of items of q into qsize   if psize <> qsize then      return false   end if      #using grep so we can kill tabs and returns as well as spaces   put replaceText (p,"\s" , "") into p   put replaceText(q, "\s" , "") into q      /*   #first check that every item of list a appears in b   #time is O(psize * qsize) == O(psize^2)   repeat for each item i in p      if i is not among the items of q then         return false      end if   end repeat   */      #then check that each item appears the same number of times   sort items of p      #time is O(psize^2)   sort items of q       #time is O(qsize^2)   return p is q      /* repeat with c = 1 to asize     #time is O(asize)   if item c of a <> item c of b then      return false   end ifend repeat*/end listsHaveSameElementson testListsHaveSameElements   local c1, c2   put "a,b,c" into c1   put "c,b,a" into c2   #assert listsHaveSameElements(c1,c2)      assertListsEqual c1, c2   #   if not listsHaveSameElements(c1, c2) then   #      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has different elements than" && c2    #   end if      put "c,b ,a" into c2   #assert listsHaveSameElements(c1,c2)   if not listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has different elements than" && c2    end if      put "c,b,aa" into c2   #assert false listsHaveSameElements(c1,c2)   if listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has same elements as" && c2    end if      put "c,b,a,a" into c2   #assert false listsHaveSameElements(c1,c2)   if listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has same elements as" && c2    end if      put "" into c2   #assert false listsHaveSameElements(c1,c2)   if listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has same elements as" && c2    end ifend testListsHaveSameElements/* send our test Err messages somewhere useful */on logTestErr errMsg   # answer errMsg    #cheap shortcut, maybe better to put into a field or stack property??   put errMsg & return & return after fld "errLog"end logTestErr/* like logTestErr, send our Err messages somewhere useful */on logErr errMsg   # answer errMsg    #cheap shortcut, maybe better to put into a field or stack property??   put errMsg & return & return after fld "errLog"end logErr