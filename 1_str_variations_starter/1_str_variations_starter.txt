# created as stack "moose60g:students:class_of_2003:Elan Guterman:work:strings" on 9/10/02on openstack   send "choose browse tool" to me in .5 second   answer "Load stack script from external file?" with "Nah" or "Load"   if it is "Load" then      send "loadStackScript" to button "loadStackScriptBtn" in 0.5 second   end if   #how about try loadStackScript right now, rather than manually push the button.   pass openstackend openstack#note: complement "loadStackScript" is in the button "loadStackScriptBtn" on card 1#this squawks if there's a failure result, otherwise happens silently.#this is very similar to saveInfoStack, below. Refactor?#Uh-Oh! Be sure of Which stack script is getting saved! I overwrote a mainstack#script with the little script from infoStack when info stack was frontmost!!on saveStackScript stackname   if stackName is empty then      put the mainstack of this stack into stackName         #is always shortname, without prefix "stack"   else if not exists(stack stackName) then      exit saveStackScript   end if      local extraname    if stackname <> the mainstack of this stack then      #substacks shouldn't be saved to same file name as mainstack!      # gonna add suffix "extraname " for substacks      put "-" & stackname into extraname    else      put empty into extraname    end if      local savePath   #put the filename of this stack into savePath  #not good enough if script is called by substack   put the filename of stack the mainstack of this stack into savePath      local whereToSave   put ("file:" & savePath) into whereToSave   #now gotta remove our filename?, OR just use a ".txt" suffix!   set the itemdelimiter to "."   delete last item of whereToSave    put extraname & ".txt" after whereToSave   #[]loadStackScript for substack has to know about this custom name!      #livecode 7+ has textEncode and textDecode which it recommends using for text i/o   #so that unicode and other encodings are shared properly with outside world.   #alternatively, try   open file "log.txt" for utf-8 text read -- Opens a file as UTF-8   # (Also see the textDecode in the loadStackScript in our loadStackScriptBtn script)   set the itemdel to "."   if item 1 of the version > 6 then       put textEncode( the script of this stack, "UTF-8")  into url whereToSave   else      put the script of stack stackName into url whereToSave   end if   local whatHappened   put the result into whatHappened   if whatHappened is not empty then      answer whatHappened   end if   put "saved the script"end saveStackScript#this is very similar to saveStackScript, above. Refactor?on saveInfoStack     local infoText   if not exists (stack "str_variations_info") then      put "Huh? Can't find stack 'str_variations_info'"      exit saveInfoStack   end if   repeat with c = 1 to the number of cards of stack "str_variations_info"      put "#  ======   " && the short name of card c of stack "str_variations_info" & return after infoText      put field "info" of card c of stack "str_variations_info" after infoText      put return & return after infoText   end repeat      #ask file "Save stack script where?" with "genvar.txt"   #put it into savePath   #   if it is empty then    #      exit to top   #   end if   local savePath   #put the filename of this stack into savePath  #not good enough is script is called by substack   put the filename of stack the mainstack of this stack into savePath   local whereToSave   put ("file:" & savePath) into whereToSave   #now gotta remove our filename, OR just use a txt suffix   set the itemdelimiter to "/"   put "README.md" into the last item of whereToSave      #livecode 7+ has textEncode and textDecode which it recommends using for text i/o   #so that unicode and other encodings are shared properly with outside world.   # (Also see the textDecode in the loadStackScript in our loadStackScriptBtn script)   set the itemdel to "."   if item 1 of the version > 6 then       put textEncode( infoText, "UTF-8")  into url whereToSave   else      put infoText into url whereToSave   end if   local whatHappened   put the result into whatHappened   if whatHappened is not empty then      answer whatHappened   end if   put "saved the info"end saveInfoStack#dictionary says, "Sent to the current card when the stack is about to be saved."#"Handle the saveStackRequest message if you need to do cleanup or other actions before a stack is saved."on saveStackRequest   saveStackScript     #works silently unless erro   saveInfoStack       #works silently unless error   pass saveStackRequestend saveStackRequest/*This should construct and save all the possible strings thatare single operation changes to the starter.(i.e. one insertion, or one deletion, or one mutation)Louis points out that some mutations are more likely than others,so we'll need a fancy cost function that includes that knowledge.*/on doVariations   put empty into cd fld "output"   local starter   put card field "starter" into starter       local theVariations   put makeAllVariations( starter ) into theVariations   put theVariations into fld "output"end doVariations#hmmm, shouldn't we specify a weighted sum of changes that we allow,#so if insertions cost 2, and deletions cost 1, and howManyChanges is 2#then we could get 1 insertion or 2 deletions, etc.function makeAllVariations starter howManyChanges   if starter is empty then      return empty   end if      if howManyChanges <= 0 then      return starter   end if      local starterLength   put the number of chars of starter into starterLength      return starter   #fake answer, as testing will show.end makeAllVariations#what about rna? "actg" should be #[]test this more, harderfunction randomBase   return item random(4) of bases()end randomBasefunction isBase base   return base in bases()end isBasefunction bases   return the bases of this stack  #"a,c,g,t"end basesfunction isBases dataString   repeat for each char c in dataString      if not isBase(c) then return false   end repeat   return trueend isBases#if newBase is empty, choose a random replacement basefunction pointMutation dataString, pos, newBase   local dataLength   put the number of chars of dataString into dataLength   if dataString is empty then      return empty   else if not isBases(dataString) then      answer "Wha??? How can I mutate non-base '" & dataString & "'."      breakpoint      exit to top      #quit   end if      if pos is empty then      put random(dataLength) into pos   else if pos is not a number then      answer "Wha??? How can I mutate non-numerical position" && pos && "of string '" & dataString & "'."      breakpoint      exit to top   else if pos > dataLength then      answer "Wha??? How can I mutate position" && pos && "of string '" & dataString & "', which has length" && dataLength      breakpoint      exit to top   else if pos < 1 then      answer "Wha??? How can I mutate zero or negative position" && pos && "of string '" & dataString & "'."      breakpoint      exit to top   end if      if newBase is empty then      put randomBase() into newBase   else if not isBase(newBase) then      answer "Wha??? How can put non-base " && newBase && "into string '" & dataString & "'."      breakpoint      exit to top   end if      put newBase into char pos of dataString   return dataStringend pointMutation/*on dostuff x,y   --this is a comment, in a procedure which returns nothing   put x & return after cd fld "output"   local silly   put "xyz" into silly   put y after char 2 of silly   put y before char 1 of silly   delete char 4 to 6 of silly   put char 2 to 4 of silly after silly   answer sillyend dostufffunction crazy x,y   --this is a function which returns a value   return x & yend crazy*/function otherbases base   --given one base (a,c,t, or g), this functions returns   --the other 3 separated by commas.   --Example: otherbases("a") ==> "c,t,g"   --(This is handy when you are doing mutations af some base B, because then you   --can get item 1 or 2 or 3 of otherbases(B)   --   local others   repeat for each char c in bases()      if c is not base then put c & "," after others   end repeat   delete the last char of others   return others   /*   #answer "called otherbases"   local mybases, myOthers, whereBaseIs   put "actg" into mybases   put "c,g,t   a,g,t   a,c,g    a,c,t" into myOthers   put offset(base,mybases) into whereBaseIs   --offset says where something is   if whereBaseIs < 1 or whereBaseIs > 4 then      answer "Bad base '" & base & "'"   else      local finalAnswer      put word whereBaseIs of myOthers into finalAnswer --note "word"      return finalAnswer   end if   */end otherbases/*#notes re assert from livecode 6.6.0 release notesAn experimental command has been added to support writing tests. The assert command has two forms.The first form evaluates an expression and checks to see if the it evaluates to true or false:assert exprassert true exprassert false exprThe second form evaluates an expression and checks to see if it throws an error or not:assert success exprassert failure exprIn either case if the condition fails, then an assertError message is sent to the object containing the command:assertError handlerName, line, column, objectLongIdExamples:assert 1 is 1 -- succeedsassert true "black" is "white" -- failsassert false "hello" is a number -- succeedsassert false 1 + 1 = 2 -- failsassert success 1 + 1 -- succeedsassert failure 1 + "z" -- fails*/#usage: (Hey! In your statement, use single quotes when you mean double quotes.#We'll fix 'em here. You CAN'T use single quotes in your statement. Sorry. Get over it.#      assertEqual "makeAllVariations('a',0)", "a"         ## note: assertEqual will turn the 1st arg into stmt with double quotes, and see if it equals 2nd arg.# assertEqual will provide good errMsg! # other ugly way of doing this....# assertLGM (makeAllVariations("a",0) is "a"), "makeAllVariations('a',0) didn't return 'a' as expected", true  on assertEqual functio, expectedReturn, doDebugIfUnhappy   if doDebugIfUnhappy is empty then      put true into doDebugIfUnhappy   end if      replace "'" with quote in functio   local actualReturn   do "put (" & functio & ") into actualReturn"      if actualReturn is expectedReturn then      #happy   else      local errMsg      put functio && "returned '" & actualReturn & "'; we expected '" & expectedReturn & "'." into errMsg      logTestErr( errMsg )      if doDebugIfUnhappy then         breakpoint      end if   end ifend assertEqual#allows fancy equality to be determined by calling the specified function#usage:#      assertFancyEqual "makeAllVariations('a',1)", "a,c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,", "listsHaveSameElements(#1, #2)"#What we're saying here is, use the function specified in the third arg to compare the first statement to the 2nd arg (expected answer)on assertFancyEqual functio, expectedReturn, equalityTest, doDebugIfUnhappy   if doDebugIfUnhappy is empty then      put true into doDebugIfUnhappy   end if      replace "'" with quote in functio   local actualReturn   do "put (" & functio & ") into actualReturn"      replace "'" with quote in equalityTest   replace "#1" with functio in equalityTest   replace "#2" with expectedReturn in equalityTest      local worked   do "put (" & equalityTest & ") into worked"      if worked then      #happy   else      local errMsg      put functio && "returned '" & actualReturn & "'; we expected '" & expectedReturn & "'." into errMsg      logTestErr( errMsg )      if doDebugIfUnhappy then         breakpoint      end if   end ifend assertFancyEqual#our rough draft of assert, which might be better than livecode's crash out?#usage   assertLGM 1, is, 1, "wot do? 1Â­1!", trueon assertLGM bool, errMsg, doDebugIfUnhappy   #local res   #do "put (" & value1 & relationship & value2 & ") into res"    if bool is empty then      logTestErr "we were given an empty assertion for some reason"      exit assertLGM   end if   if errMsg is empty then      put "assert was untrue" into errMsg   end if   if doDebugIfUnhappy is empty then      put true into doDebugIfUnhappy   end if   if bool then      #happy   else      logTestErr( errMsg )      if doDebugIfUnhappy then         breakpoint      end if   end if      #   switch (relationship)     #      case "="       #      case "=="      #      case "is"   #      case "equals"   #         -- all of the above case conditions execute the following   #         -- statements:   #         if value1 = value2 then   #            #happy   #         else   #            logTestErr( errMsg )   #            if doDebugIfUnhappy then   #               breakpoint   #            end if   #         end if   #         break   #      case "<>"   #      case "­"   #      case "is not"   #      case "not ="   #         -- all of the above case conditions execute the following   #         -- statements:   #         ...   #      default   #         logTestErr "Unknown relationship '" & relationship & "' in assertLGM "   #         breakpoint   #   end switchend assertLGMon testMakeAllVariations   #set the randomSeed to 4570422   local wassup   put 3 into wassup      assertEqual "makeAllVariations('a',0)", "a"            #note: assertEqual will turn the 1st arg into stmt with double quotes, and see if it equals 2nd arg.   #assertEqual will provide good errMsg!    #other ugly way of doing this....   #assertLGM (makeAllVariations("a",0) is "a"), "makeAllVariations('a',0) didn't return 'a' as expected", true      #variations are mutations, insert (before), insert after,delete   #assert makeAllVariations("a",/*howMany:*/1) is "a,c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,"   assertFancyEqual "makeAllVariations('a',1)", "a,c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,", "listsHaveSameElements(#1, #2)"   #assertLGM listsHaveSameElements(makeAllVariations("a",1), "a,c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,"),"makeAllVariations('a',01) didn't return expected results", true   put 4 into wassupend testMakeAllVariations/* not sets: there can be repeated elements (which we'll have to count) *//* If these sets are not too big, we could sort them! */function listsHaveSameElements p q   if p contains return or q contains return then      answer "Whoa! Our lists aren't supposed to have returns in them"      breakpoint      exit to top   end if   if p is empty and q is empty then       return true   end if   local psize,qsize   put the number of items of p into psize   put the number of items of q into qsize   if psize <> qsize then      return false   end if      #using grep so we can kill tabs and returns as well as spaces   put replaceText (p,"\s" , "") into p   put replaceText(q, "\s" , "") into q      /*   #first check that every item of list a appears in b   #time is O(psize * qsize) == O(psize^2)   repeat for each item i in p      if i is not among the items of q then         return false      end if   end repeat   */      #then check that each item appears the same number of times   sort items of p      #time is O(psize^2)   sort items of q       #time is O(qsize^2)   return p is q      /* repeat with c = 1 to asize     #time is O(asize)   if item c of a <> item c of b then      return false   end ifend repeat*/end listsHaveSameElementson testListsHaveSameElements   local c1, c2   put "a,b,c" into c1   put "c,b,a" into c2   #assert listsHaveSameElements(c1,c2)      assertFancyEqual c1, c2, "listsHaveSameElements(#1, #2)"   #   if not listsHaveSameElements(c1, c2) then   #      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has different elements than" && c2    #   end if      put "c,b ,a" into c2   #assert listsHaveSameElements(c1,c2)   if not listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has different elements than" && c2    end if      put "c,b,aa" into c2   #assert false listsHaveSameElements(c1,c2)   if listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has same elements as" && c2    end if      put "c,b,a,a" into c2   #assert false listsHaveSameElements(c1,c2)   if listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has same elements as" && c2    end if      put "" into c2   #assert false listsHaveSameElements(c1,c2)   if listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has same elements as" && c2    end ifend testListsHaveSameElements/* send our test Err messages somewhere useful */on logTestErr msg   answer msg    #cheap shortcut, maybe better to put into a field or stack property??   put msg after fld "output"end logTestErr msg#checking, asks the human to make sure that function otherbases workson testOtherBases   put "- - - - - - - - - - -" & return after cd fld "output"   put "checking to make sure that otherbases works:" & return after cd fld "output"   local currBase, others   repeat for each item currBase in bases()      put "currBase =" && currBase & ", other bases are {" after cd fld "output"      put otherbases(currBase) into others     # otherwise called repeatedly      repeat for each item X in others         put X & "," after cd fld "output"         #if X < 3 then put "," after cd fld "output"      end repeat      delete last char of cd fld "output"   #      put "}" & return after cd fld "output"   end repeat   put "- - - - - - - - - - done testing" & return after cd fld "output"end testOtherBases