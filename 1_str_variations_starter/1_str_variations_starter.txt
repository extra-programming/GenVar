# created as stack "moose60g:students:class_of_2003:Elan Guterman:work:strings" on 9/10/02





on openstack
   send "choose browse tool" to me in .5 second
   answer "Load stack script from external file?" with "Nah" or "Load"
   if it is "Load" then
      send "loadStackScript" to button "loadStackScriptBtn" in 0.5 second
   end if
   #how about try loadStackScript right now, rather than manually push the button.
   pass openstack
end openstack



#note: complement "loadStackScript" is in the button "loadStackScriptBtn" on card 1
#this squawks if there's a failure result, otherwise happens silently.
#this is very similar to saveInfoStack, below. Refactor?
#Uh-Oh! Be sure of Which stack script is getting saved! I overwrote a mainstack
#script with the little script from infoStack when info stack was frontmost!!
on saveStackScript stackname
   if stackName is empty then
      put the mainstack of this stack into stackName   
      #is always shortname, without prefix "stack"
   else if not exists(stack stackName) then
      exit saveStackScript
   end if
   
   local extraname 
   if stackname <> the mainstack of this stack then
      #substacks shouldn't be saved to same file name as mainstack!
      # gonna add suffix "extraname " for substacks
      put "-” & stackname into extraname 
   else
      put empty into extraname 
   end if
   
   local savePath
   #put the filename of this stack into savePath  #not good enough if script is called by substack
   put the filename of stack the mainstack of this stack into savePath
   
   local whereToSave
   put ("file:" & savePath) into whereToSave
   #now gotta remove our filename?, OR just use a ".txt" suffix!
   set the itemdelimiter to "."
   delete last item of whereToSave 
   put extraname & ".txt" after whereToSave
   #[]loadStackScript for substack has to know about this custom name!
   
   #livecode 7+ has textEncode and textDecode which it recommends using for text i/o
   #so that unicode and other encodings are shared properly with outside world.
   #alternatively, try   open file "log.txt" for utf-8 text read -- Opens a file as UTF-8
   # (Also see the textDecode in the loadStackScript in our loadStackScriptBtn script)
   set the itemdel to "."
   if item 1 of the version > 6 then 
      put textEncode( the script of this stack, "UTF-8")  into url whereToSave
   else
      put the script of stack stackName into url whereToSave
   end if
   local whatHappened
   put the result into whatHappened
   if whatHappened is not empty then
      answer whatHappened
   end if
   put "saved the script"
end saveStackScript


#this is very similar to saveStackScript, above. Refactor?
on saveInfoStack  
   local infoText
   if not exists (stack "str_variations_info") then
      put "Huh? Can't find stack 'str_variations_info'"
      exit saveInfoStack
   end if
   repeat with c = 1 to the number of cards of stack "str_variations_info"
      put "#  ======   " && the short name of card c of stack "str_variations_info" & return after infoText
      put field "info" of card c of stack "str_variations_info" after infoText
      put return & return after infoText
   end repeat
   
   #ask file "Save stack script where?" with "genvar.txt"
   #put it into savePath
   #   if it is empty then 
   #      exit to top
   #   end if
   local savePath
   #put the filename of this stack into savePath  #not good enough is script is called by substack
   put the filename of stack the mainstack of this stack into savePath
   local whereToSave
   put ("file:" & savePath) into whereToSave
   #now gotta remove our filename, OR just use a txt suffix
   set the itemdelimiter to "/"
   put "README.md" into the last item of whereToSave
   
   #livecode 7+ has textEncode and textDecode which it recommends using for text i/o
   #so that unicode and other encodings are shared properly with outside world.
   # (Also see the textDecode in the loadStackScript in our loadStackScriptBtn script)
   set the itemdel to "."
   if item 1 of the version > 6 then 
      put textEncode( infoText, "UTF-8")  into url whereToSave
   else
      put infoText into url whereToSave
   end if
   local whatHappened
   put the result into whatHappened
   if whatHappened is not empty then
      answer whatHappened
   end if
   put "saved the info"
end saveInfoStack


#dictionary says, "Sent to the current card when the stack is about to be saved."
#"Handle the saveStackRequest message if you need to do cleanup or other actions before a stack is saved."
on saveStackRequest
   saveStackScript     #works silently unless erro
   saveInfoStack       #works silently unless error
   pass saveStackRequest
end saveStackRequest







/*
This should construct and save all the possible strings that
are single operation changes to the starter.
(i.e. one insertion, or one deletion, or one mutation)
Louis points out that some mutations are more likely than others,
so we'll need a fancy cost function that includes that knowledge.
*/
on doVariations
   put empty into cd fld "output"
   local starter

   put card field "starter" into starter
    
   local theVariations
   put makeAllVariations( starter ) into theVariations
   put theVariations into fld "output"
end doVariations


#hmmm, shouldn't we specify a weighted sum of changes that we allow,
#so if insertions cost 2, and deletions cost 1, and howManyChanges is 2
#then we could get 1 insertion or 2 deletions, etc.
function makeAllVariations starter howManyChanges
   if starter is empty then
      return empty
   end if
   
   if howManyChanges <= 0 then
      return starter
   end if
   
   local starterLength
   put the number of chars of starter into starterLength
   
   return starter   #fake answer, as testing will show.
end makeAllVariations


#what about rna? "actg" should be 
#[]test this more, harder
function randomBase
   return item random(4) of bases()
end randomBase


function isBase base
   return base in bases()
end isBase


function bases
   return the bases of this stack  #"a,c,g,t"
end bases


function isBases dataString
   repeat for each char c in dataString
      if not isBase(c) then return false
   end repeat
   return true
end isBases


#if newBase is empty, choose a random replacement base
function pointMutation dataString, pos, newBase
   local dataLength
   put the number of chars of dataString into dataLength
   if dataString is empty then
      return empty
   else if not isBases(dataString) then
      answer "Wha??? How can I mutate non-base '" & dataString & "'."
      breakpoint
      exit to top
      #quit
   end if
   
   if pos is empty then
      put random(dataLength) into pos
   else if pos is not a number then
      answer "Wha??? How can I mutate non-numerical position" && pos && "of string '" & dataString & "'."
      breakpoint
      exit to top
   else if pos > dataLength then
      answer "Wha??? How can I mutate position" && pos && "of string '" & dataString & "', which has length" && dataLength
      breakpoint
      exit to top
   else if pos < 1 then
      answer "Wha??? How can I mutate zero or negative position" && pos && "of string '" & dataString & "'."
      breakpoint
      exit to top
   end if
   
   if newBase is empty then
      put randomBase() into newBase
   else if not isBase(newBase) then
      answer "Wha??? How can put non-base " && newBase && "into string '" & dataString & "'."
      breakpoint
      exit to top
   end if
   
   put newBase into char pos of dataString
   return dataString
end pointMutation

/*
on dostuff x,y
   --this is a comment, in a procedure which returns nothing
   put x & return after cd fld "output"
   local silly
   put "xyz" into silly
   put y after char 2 of silly
   put y before char 1 of silly
   delete char 4 to 6 of silly
   put char 2 to 4 of silly after silly
   answer silly
end dostuff


function crazy x,y
   --this is a function which returns a value
   return x & y
end crazy
*/

function otherbases base
   --given one base (a,c,t, or g), this functions returns
   --the other 3 separated by commas.
   --Example: otherbases("a") ==> "c,t,g"
   --(This is handy when you are doing mutations af some base B, because then you
   --can get item 1 or 2 or 3 of otherbases(B)
   --
   local others
   repeat for each char c in bases()
      if c is not base then put c & "," after others
   end repeat
   delete the last char of others
   return others
   /*
   #answer "called otherbases"
   local mybases, myOthers, whereBaseIs
   put "actg" into mybases
   put "c,g,t   a,g,t   a,c,g    a,c,t" into myOthers
   put offset(base,mybases) into whereBaseIs   --offset says where something is
   if whereBaseIs < 1 or whereBaseIs > 4 then
      answer "Bad base '" & base & "'"
   else
      local finalAnswer
      put word whereBaseIs of myOthers into finalAnswer --note "word"
      return finalAnswer
   end if
   */
end otherbases



/*
#notes re assert from livecode 6.6.0 release notes
An experimental command has been added to support writing tests. The assert command has two forms.

The first form evaluates an expression and checks to see if the it evaluates to true or false:
assert expr
assert true expr
assert false expr

The second form evaluates an expression and checks to see if it throws an error or not:
assert success expr
assert failure expr

In either case if the condition fails, then an assertError message is sent to the object containing the command:
assertError handlerName, line, column, objectLongId

Examples:
assert 1 is 1 -- succeeds
assert true "black" is "white" -- fails
assert false "hello" is a number -- succeeds
assert false 1 + 1 = 2 -- fails
assert success 1 + 1 -- succeeds
assert failure 1 + "z" -- fails
*/

#our rough draft of assert, which might be better than livecode's crash out?
#usage   assertLGM 1, is, 1, "wot do? 1­1!", true
on assertLGM value1, relationship, value2, errMsg, doDebugIfUnhappy
   switch (relationship)  
      case "="    
      case "=="   
      case "is"
      case "equals"
         -- all of the above case conditions execute the following
         -- statements:
         if value1 = value2 then
            #happy
         else
            errLog( errMsg )
            if doDebugIfUnhappy then
               breakpoint
            end if
         end if
         break
      default
         go next card
   end switch
end assertLGM




on testMakeAllVariations
   #set the randomSeed to 4570422
   local wassup
   put 3 into wassup
   
   assert makeAllVariations("a",0) is "a"
   
   #assuming order is mutations, insert (before), insert after,delete
   assert makeAllVariations("a",1) is "a,c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,"
   #assert setsAreEqual(makeAllVariations("a",1), "a,c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,")
   put 4 into wassup
end testMakeAllVariations


#checking, asks the human to make sure that function otherbases works
on testOtherBases
   put "- - - - - - - - - - -" & return after cd fld "output"
   put "checking to make sure that otherbases works:" & return after cd fld "output"
   local currBase, others
   repeat for each item currBase in bases()
      put "currBase =" && currBase & ", other bases are {" after cd fld "output"
      put otherbases(currBase) into others     # otherwise called repeatedly
      repeat for each item X in others
         put X & "," after cd fld "output"
         #if X < 3 then put "," after cd fld "output"
      end repeat
      delete last char of cd fld "output"   #
      put "}" & return after cd fld "output"
   end repeat
   put "- - - - - - - - - - done testing" & return after cd fld "output"
end testOtherBases
