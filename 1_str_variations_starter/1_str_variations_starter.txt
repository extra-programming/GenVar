# created as stack "moose60g:students:class_of_2003:Elan Guterman:work:strings" on 9/10/2002on openStack   send "choose browse tool" to me in .5 second   answer "Load stack script from external file?" with "Nah" or "Load"   if it is "Load" then      send "loadStackScript" to button "loadStackScriptBtn" in 0.5 second   end if   #how about try loadStackScript right now, rather than manually push the button.   pass openStackend openStack#note: complement "loadStackScript" is in the button "loadStackScriptBtn" on card 1#this squawks if there's a failure result, otherwise happens silently.#this is very similar to saveInfoStack, below. Refactor?#Uh-Oh! Be sure of Which stack script is getting saved! I overwrote a mainstack#script with the little script from infoStack when info stack was frontmost!!on saveStackScript stackname   if stackName is empty then      put the mainstack of this stack into stackName         #is always shortname, without prefix "stack"   else if not exists(stack stackName) then      exit saveStackScript   end if      local extraname    if stackname <> the mainstack of this stack then      #substacks shouldn't be saved to same file name as mainstack!      # gonna add suffix "extraname " for substacks      put "-" & stackname into extraname    else      put empty into extraname    end if      local savePath   #put the filename of this stack into savePath  #not good enough if script is called by substack   put the filename of stack the mainstack of this stack into savePath      local whereToSave   put ("file:" & savePath) into whereToSave   #now gotta remove our filename?, OR just use a ".txt" suffix!   set the itemdelimiter to "."   delete last item of whereToSave    put extraname & ".txt" after whereToSave   #[]loadStackScript for substack has to know about this custom name!      #livecode 7+ has textEncode and textDecode which it recommends using for text i/o   #so that unicode and other encodings are shared properly with outside world.   #alternatively, try   open file "log.txt" for utf-8 text read -- Opens a file as UTF-8   # (Also see the textDecode in the loadStackScript in our loadStackScriptBtn script)   set the itemdel to "."   if item 1 of the version > 6 then       put textEncode( the script of this stack, "UTF-8")  into url whereToSave   else      put the script of stack stackName into url whereToSave   end if   local whatHappened   put the result into whatHappened   if whatHappened is not empty then      answer whatHappened   end if   put "saved the script"end saveStackScript#this is very similar to saveStackScript, above. Refactor?on saveInfoStack     local infoText   if not exists (stack "str_variations_info") then      put "Huh? Can't find stack 'str_variations_info'"      exit saveInfoStack   end if   repeat with c = 1 to the number of cards of stack "str_variations_info"      put "#  ======   " && the short name of card c of stack "str_variations_info" & return after infoText      put field "info" of card c of stack "str_variations_info" after infoText      put return & return after infoText   end repeat      #ask file "Save stack script where?" with "genvar.txt"   #put it into savePath   #   if it is empty then    #      exit to top   #   end if   local savePath   #put the filename of this stack into savePath  #not good enough is script is called by substack   put the filename of stack the mainstack of this stack into savePath   local whereToSave   put ("file:" & savePath) into whereToSave   #now gotta remove our filename, OR just use a txt suffix   set the itemdelimiter to "/"   put "README.md" into the last item of whereToSave      #livecode 7+ has textEncode and textDecode which it recommends using for text i/o   #so that unicode and other encodings are shared properly with outside world.   # (Also see the textDecode in the loadStackScript in our loadStackScriptBtn script)   set the itemdel to "."   if item 1 of the version > 6 then       put textEncode( infoText, "UTF-8")  into url whereToSave   else      put infoText into url whereToSave   end if   local whatHappened   put the result into whatHappened   if whatHappened is not empty then      answer whatHappened   end if   put "saved the info"end saveInfoStack#dictionary says, "Sent to the current card when the stack is about to be saved."#"Handle the saveStackRequest message if you need to do cleanup or other actions before a stack is saved."on saveStackRequest   saveStackScript     #works silently unless erro   saveInfoStack       #works silently unless error   pass saveStackRequestend saveStackRequest/*This should construct and save all the possible strings thatare single operation changes to the starter.(i.e. one insertion, or one deletion, or one mutation)Louis points out that some mutations are more likely than others,so we'll need a fancy cost function that includes that knowledge.*/on doVariations   put empty into cd fld "results"   local starter, howManyChanges      put word 1 of card field "starter" into starter    #using 'word 1' to get rid of blanks   put fld "howManyChanges" into howManyChanges      local theVariations   put makeAllVariations( starter, howManyChanges ) into theVariations   put theVariations into fld "results"end doVariations#hmmm, shouldn't we specify a weighted sum of changes that we allow,#so if insertions cost 2, and deletions cost 1, and howManyChanges is 2#then we could get 1 insertion or 2 deletions, etc.function makeAllVariations starter howManyChanges   if starter is empty then      return empty   end if   local thisMutants,nextMutants   put word 1 of starter into starter   #gets rid of leading and trailing blanks   if howManyChanges is empty then      logErr "makeAllVariations wasn't told how many variations to do!"      put 1 into howManyChanges   end if      put starter into thisMutants   repeat howManyChanges times      put "" into nextMutants      repeat for each item mutant in thisMutants         put concatLists( nextMutants, makeOneVariation(mutant) ) into nextMutants         // Err? put concatLists( thisMutants, makeOneVariation(mutant) ) into nextMutants      end repeat      # no, don't erase last comma: means an empty sequence, deliberately.      #      if the last char of nextMutants is "," then      #         delete the last char of nextMutants #kill the trailing comma      #      end if      put nextMutants into thisMutants   end repeat   return thisMutantsend makeAllVariationsfunction makeOneVariation starter   if starter is empty then      return empty   end if   put word 1 of starter into starter   #gets rid of leading and trailing blanks      local mutants,starterLength   put the number of chars of starter into starterLength      #### make variations ####      # unchanged   #if false then put starter & "," after mutants # Is this a mutation?   put concatLists( mutants, makePointMutations( starter ) ) into mutants   put concatLists( mutants, makeDeletions( starter ) ) into mutants   return mutantsend makeOneVariation#Handy utility for gluing two lists together and separating them only if both have content.function concatLists list1 list2 currItemDel   if currItemDel is empty then      put itemDel into currItemDel   end if   if list1 is empty then       return list2   else if list2 is empty then      return list1   else      return list1 & currItemdel & list2    #will normally be using ","   end ifend concatListson testConcatLists   assertListsEqual "concatLists('ac,gt' , '' )" ,    "ac,gt"   assertListsEqual "concatLists('' , 'ac,gt' )" ,    "ac,gt"   assertListsEqual "concatLists('ac,gt' , 'ttt' )" ,    "ac,gt,ttt"   assertListsEqual "concatLists(',' , '' )" ,    ","   assertListsEqual "concatLists(',' , ',' )" ,    ",,,"end testConcatLists#hmmm, thinking about strands...#isn't this basically two splits and a glue without the middle guy anymore???#and insertion is one split and two glues#and move is two (or three) splits and two (or three) glues.#Will return every possible sequence that comes when starter sequence#has one deletion of every possible size (including deleting the whole thing!?)function makeDeletions starter    if starter is empty then      return empty   end if   put word 1 of starter into starter   #gets rid of leading and trailing blanks      local mutants,starterLength   put the number of chars of starter into starterLength   repeat with deletionLength = 1 to starterLength      put concatLists( mutants, makeSpecSizeDeletions(starter,deletionLength) ) into mutants   end repeat   # following is unnecessary now that I'm using concatLists...   #   if last word of mutants is "," and the number of words of mutants is 1 then   #      #don't delete last comma because all we've got is "  ,   " and   #      #we might want to report empty sequences as ","     ?? (e.g. deleted all elements)   #   else if the last char of mutants is ","  then   #      delete the last char of mutants  #kill the trailing comma   #   end if   return mutantsend makeDeletions#will return every possible sequence that comes when starter sequence#has deletions of the specified size. Is called by makeDeletions( ) which#loops along specifying every possible size deletions.function makeSpecSizeDeletions starter deletionLength   if starter is empty then      return empty   end if   put word 1 of starter into starter   #gets rid of leading and trailing blanks   local starterLength   put the number of chars of starter into starterLength   if deletionLength >= starterLength then      return ","     #should this return empty ??   # ?? should this return "," as one blank item??   end if   local mutants   repeat with i = 1 to (starterLength + 1 - deletionLength)      local starterCopy      put starter into starterCopy      delete char i to (i - 1 + deletionLength) of starterCopy      put concatLists( mutants, starterCopy ) into  mutants   end repeat      # following is not necessary now that I'm using concatLists( )...   #   if last word of mutants is "," and the number of words of mutants is 1 then   #      #don't delete last comma because all we've got is "  ,   " and   #      #we might want to report empty sequences as ","     ?? (e.g. deleted all elements)   #   else if the last char of mutants is "," then   #      delete the last char of mutants  #kill the trailing comma   #   end if   return mutantsend makeSpecSizeDeletions#thinking about strands... #might be two splits and a glue of somebody else (delete + insert)#OR think of it as a copying error while duplicating#?? Can a base pair change into another??function makePointMutations starter    if starter is empty then      return empty   # empty? can't mutate a nothing?   end if   put word 1 of starter into starter   #gets rid of leading and trailing blanks   local mutants,starterLength   put the number of chars of starter into starterLength   repeat with i = 1 to starterLength      repeat for each item base in otherBases(char i of starter)         put concatLists(mutants, pointMutation(starter,i,base)) into mutants      end repeat   end repeat   # following not necessary now that I'm using concatLists   #   if the last char of mutants is "," then   #      delete the last char of mutants  #kill the trailing comma   #   end if   return mutantsend makePointMutations#what about rna? "actg" should be #[]test this more, harderfunction randomBase   return item random(4) of bases( )end randomBase#function isBase base   #itemOffset will be 0 if the base isn't found   set wholematches to true   #beware, comma was being found in comma separated list. Maybe wholematches will fix?   return itemOffset( base, bases( ) ) > 0 end isBaseon testIsBase   assertEqual "isBase('a')", true   assertEqual "isBase('c')", true   assertEqual "isBase('t')", true   assertEqual "isBase('g')", true   assertEqual "isBase(',')", false   assertEqual "isBase('u')", false    #unless we use rna which we probably will someday, might   assertEqual "isBase('!')", falseend testIsBasefunction bases   return the bases of this stack  #"a,c,g,t"end bases#verifies that (each CHAR! of) a text string is comprised of bases only!function isBases dataString   repeat for each char c in dataString      if not isBase(c) then return false   end repeat   return trueend isBaseson testIsBases   assertEqual "isBases('a')", true   assertEqual "isBases('c')", true   assertEqual "isBases('t')", true   assertEqual "isBases('actctctgaggggaaattttttttt')", true   assertEqual "isBases('')", true    #valid since it would be the result of deletion of single base    assertEqual "isBases('g')", true   assertEqual "isBases('a,c')", false   assertEqual "isBases('actctctgaggggaaattqttttttt')", false   assertEqual "isBases('u')", false    #unless we use rna which we probably will someday, might   assertEqual "isBases('!')", falseend testIsBases#if newBase is empty, choose a random replacement basefunction pointMutation dataString, pos, newBase   put word 1 of dataString into dataString   put word 1 of newBase into newBase   local dataLength   put the number of chars of dataString into dataLength   if dataString is empty then      return empty   else if not isBases(dataString) then      logErr "in pointMutation( ): Wha??? How can I mutate non-base '" & dataString & "'."      breakpoint      exit to top      #quit   end if      if pos is empty then      put random(dataLength) into pos   else if pos is not a number then      logErr "in pointMutation( ): Wha??? How can I mutate non-numerical position" && pos && "of string '" & dataString & "'."      breakpoint      exit to top   else if pos > dataLength then      logErr "in pointMutation( ): Wha??? How can I mutate position" && pos && "of string '" & dataString & "', which has length" && dataLength      breakpoint      exit to top   else if pos < 1 then      logErr "in pointMutation( ): Wha??? How can I mutate zero or negative position" && pos && "of string '" & dataString & "'."      breakpoint      exit to top   end if      if newBase is empty then      put randomBase() into newBase   else if not isBase(newBase) then      logErr "in pointMutation( ): Wha??? How can put non-base " && newBase && "into string '" & dataString & "'."      breakpoint      exit to top   end if      put newBase into char pos of dataString   return dataStringend pointMutation/*on dostuff x,y   --this is a comment, in a procedure which returns nothing   put x & return after cd fld "output"   local silly   put "xyz" into silly   put y after char 2 of silly   put y before char 1 of silly   delete char 4 to 6 of silly   put char 2 to 4 of silly after silly   answer sillyend dostufffunction crazy x,y   --this is a function which returns a value   return x & yend crazy*/function otherBases base   --given one base (a,c,t, or g), this functions returns   --the other 3 separated by commas.   --Example: otherbases("a") ==> "c,t,g"   --(This is handy when you are doing mutations af some base B, because then you   --can get item 1 or 2 or 3 of otherbases(B)   --   put word 1 of base into base   #getting rid of blanks on both sides   if base is empty then      logErr "in otherBases( ' ' ): Wha? How can I find otherBases of empty base?"      return ""   # should this return empty   end if    local others   repeat for each item c in bases( )      if c is not base then put c & "," after others   end repeat   delete the last char of others   return others   /*   #answer "called otherbases"   local mybases, myOthers, whereBaseIs   put "actg" into mybases   put "c,g,t   a,g,t   a,c,g    a,c,t" into myOthers   put offset(base,mybases) into whereBaseIs   --offset says where something is   if whereBaseIs < 1 or whereBaseIs > 4 then      answer "Bad base '" & base & "'"   else      local finalAnswer      put word whereBaseIs of myOthers into finalAnswer --note "word"      return finalAnswer   end if   */end otherBases/*#notes re assert from livecode 6.6.0 release notesAn experimental command has been added to support writing tests. The assert command has two forms.The first form evaluates an expression and checks to see if the it evaluates to true or false:assert exprassert true exprassert false exprThe second form evaluates an expression and checks to see if it throws an error or not:assert success exprassert failure exprIn either case if the condition fails, then an assertError message is sent to the object containing the command:assertError handlerName, line, column, objectLongIdExamples:assert 1 is 1 -- succeedsassert true "black" is "white" -- failsassert false "hello" is a number -- succeedsassert false 1 + 1 = 2 -- failsassert success 1 + 1 -- succeedsassert failure 1 + "z" -- fails*/#usage: (Hey! In your statement, use single quotes when you mean double quotes.#We'll fix 'em here. You CAN'T use single quotes in your statement. Sorry. Get over it.#      assertEqual "makeAllVariations('a',0)", "a"         ## note: assertEqual will turn the 1st arg into stmt with double quotes, and see if it equals 2nd arg.# assertEqual will provide good errMsg! # other ugly way of doing this....# assertLGM (makeAllVariations("a",0) is "a"), "makeAllVariations('a',0) didn't return 'a' as expected", true  on assertEqual functio, expectedReturn, doDebugIfUnhappy   assertFancyEqual functio, expectedReturn, "#1 is #2", doDebugIfUnhappy   /*if doDebugIfUnhappy is empty then      put true into doDebugIfUnhappy   end if      replace "'" with quote in functio   local actualReturn   do "put (" & functio & ") into actualReturn"      if actualReturn is expectedReturn then      #happy   else      local errMsg      put functio && "returned '" & actualReturn & "'; we expected '" & expectedReturn & "'." into errMsg      logTestErr( errMsg )      if doDebugIfUnhappy then         breakpoint      end if   end if*/end assertEqual#this wil call the listsHaveSameElements( ) to compare the actual result of "functio" to expectedReturnon assertListsEqual functio, expectedReturn, doDebugIfUnhappy   assertFancyEqual functio, expectedReturn, "listsHaveSameElements(#1, #2)", doDebugIfUnhappyend assertListsEqual#allows fancy equality to be determined by calling the specified function#usage:#      assertFancyEqual "makeAllVariations('a',1)", "a,c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,", "listsHaveSameElements(#1, #2)"#What we're saying here is, use the function specified in the third arg to compare the first statement to the 2nd arg (expected answer)on assertFancyEqual functio, expectedReturn, equalityTest, doDebugIfUnhappy   if doDebugIfUnhappy is empty then      put true into doDebugIfUnhappy   end if      replace "'" with quote in functio   local actualReturn   do "put (" & functio & ") into actualReturn"      replace "'" with quote in equalityTest   replace "#1" with quote & actualReturn & quote in equalityTest   replace "#2" with quote & expectedReturn & quote in equalityTest      local worked   do "put (" & equalityTest & ") into worked"      if worked then      #happy   else      local errMsg      put "assert failed:" && functio && "returned '" & actualReturn & "'; we expected '" & expectedReturn & "'." into errMsg      logTestErr( errMsg )      if doDebugIfUnhappy then         answer errMsg & return & "Want to see debugger at breakpoint or Continue?" with "Debug" or "Continue"         if it is "Debug" then            breakpoint         end if      end if   end ifend assertFancyEqual#our rough draft of assert, which might be better than livecode's crash out?#we're not using this anymore#usage   assertLGM 1, is, 1, "wot do? 1Â­1!", true/*on assertLGM bool, errMsg, doDebugIfUnhappy   #local res   #do "put (" & value1 & relationship & value2 & ") into res"    if bool is empty then      logTestErr "we were given an empty assertion for some reason"      exit assertLGM   end if   if errMsg is empty then      put "assert was untrue" into errMsg   end if   if doDebugIfUnhappy is empty then      put true into doDebugIfUnhappy   end if   if bool then      #happy   else      logTestErr( errMsg )      if doDebugIfUnhappy then         breakpoint      end if   end if      #   switch (relationship)     #      case "="       #      case "=="      #      case "is"   #      case "equals"   #         -- all of the above case conditions execute the following   #         -- statements:   #         if value1 = value2 then   #            #happy   #         else   #            logTestErr( errMsg )   #            if doDebugIfUnhappy then   #               breakpoint   #            end if   #         end if   #         break   #      case "<>"   #      case "­"   #      case "is not"   #      case "not ="   #         -- all of the above case conditions execute the following   #         -- statements:   #         ...   #      default   #         logTestErr "Unknown relationship '" & relationship & "' in assertLGM "   #         breakpoint   #   end switchend assertLGM*/on testMakeAllVariations   #set the randomSeed to 4570422      assertListsEqual "makeAllVariations('a',0)", "a"            #note: assertEqual will run the 1st arg as stmt with double quotes instead of single quotes, and see if it equals 2nd arg.   #assertEqual will provide good errMsg!    #other ugly way of doing this....   #assertLGM (makeAllVariations("a",0) is "a"), "makeAllVariations('a',0) didn't return 'a' as expected", true      #variations are mutations, deletions, insert (before), insert after, move bases, (move & reverse? move complements?)   #assert makeAllVariations("a",/*howMany:*/1) is "a,c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,"   #assertFancyEqual "makeAllVariations('a',1)", "c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,", "listsHaveSameElements(#1, #2)"   assertListsEqual "makeAllVariations('a',1)", "c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,"   #assertLGM listsHaveSameElements(makeAllVariations("a",1), "a,c,g,t,aa,ca,ga,ta,aa,ac,ag,at,,"),"makeAllVariations('a',01) didn't return expected results", trueend testMakeAllVariations/* not sets: there can be repeated elements (which we'll have to count) *//* If these sets are not too big, we could sort them! */function listsHaveSameElements p q   if p contains return or q contains return then      answer "Whoa! Our lists aren't supposed to have returns in them"      breakpoint      exit to top   end if   if p is empty and q is empty then       return true   end if   local psize,qsize   put the number of items of p into psize   put the number of items of q into qsize   if psize <> qsize then      return false   end if      #using grep so we can kill tabs and returns as well as spaces   put replaceText (p,"\s" , "") into p   put replaceText(q, "\s" , "") into q      /*   #first check that every item of list a appears in b   #time is O(psize * qsize) == O(psize^2)   repeat for each item i in p      if i is not among the items of q then         return false      end if   end repeat   */      #then check that each item appears the same number of times   sort items of p      #time is O(psize^2)   sort items of q       #time is O(qsize^2)   return p is q      /* repeat with c = 1 to asize     #time is O(asize)   if item c of a <> item c of b then      return false   end ifend repeat*/end listsHaveSameElementson testListsHaveSameElements   local c1, c2   put "a,b,c" into c1   put "c,b,a" into c2   #assert listsHaveSameElements(c1,c2)      assertListsEqual c1, c2   #   if not listsHaveSameElements(c1, c2) then   #      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has different elements than" && c2    #   end if      put "c,b ,a" into c2   #assert listsHaveSameElements(c1,c2)   if not listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has different elements than" && c2    end if      put "c,b,aa" into c2   #assert false listsHaveSameElements(c1,c2)   if listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has same elements as" && c2    end if      put "c,b,a,a" into c2   #assert false listsHaveSameElements(c1,c2)   if listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has same elements as" && c2    end if      put "" into c2   #assert false listsHaveSameElements(c1,c2)   if listsHaveSameElements(c1, c2) then      logTestErr "fail: listsHaveSameElements( ) thinks" && c1 && "has same elements as" && c2    end ifend testListsHaveSameElements/* send our test Err messages somewhere useful */on logTestErr errMsg   # answer errMsg    #cheap shortcut, maybe better to put into a field or stack property??   put errMsg & return & return after fld "errLog"end logTestErr/* like logTestErr, send our Err messages somewhere useful */on logErr errMsg   # answer errMsg    #cheap shortcut, maybe better to put into a field or stack property??   put errMsg & return & return after fld "errLog"end logErr#checking, asks the human to make sure that function otherbases workson testOtherBases   /*put "- - - - - - - - - - -" & return after cd fld "output"   put "checking to make sure that otherbases works:" & return after cd fld "output"   local currBase, others   repeat for each item currBase in bases()      put "currBase =" && currBase & ", other bases are {" after cd fld "output"      put otherbases(currBase) into others     # otherwise called repeatedly      repeat for each item X in others         put X & "," after cd fld "output"         #if X < 3 then put "," after cd fld "output"      end repeat      delete last char of cd fld "output"   #      put "}" & return after cd fld "output"   end repeat   put "- - - - - - - - - - done testing" & return after cd fld "output"*/   assertListsEqual "otherBases('a')", "c,t,g"   assertListsEqual "otherBases('c')", "a,t,g"   assertListsEqual "otherBases('t')", "a,c,g"   assertListsEqual "otherBases('g')", "a,c,t"   assertListsEqual "otherBases(' ')", ""end testOtherBaseson testMakePointMutations   assertListsEqual "makePointMutations('acgt')" ,    "ccgt,gcgt,tcgt, aagt,aggt,atgt, acat,acct,actt, acga,acgc,acgg"end testMakePointMutationson testMakeDeletions   assertListsEqual "makeDeletions('acgt')" ,    "cgt,agt,act,acg,gt,at,ac,t,a,,"   assertListsEqual "makeDeletions('a')" ,    ","end testMakeDeletionson testMakeSpecSizeDeletions   assertListsEqual "makeSpecSizeDeletions('acgt',1)" ,    "cgt,agt,act,acg"   assertListsEqual "makeSpecSizeDeletions('acgt',2)" ,    "gt,at,ac"   assertListsEqual "makeSpecSizeDeletions('acgt',3)" ,    "t,a"   assertListsEqual "makeSpecSizeDeletions('acgt',4)" ,    ","end testMakeSpecSizeDeletions